package com.example.waterreporter.report

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import android.location.Location
import android.net.Uri
import android.util.Log
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.setValue
import androidx.core.content.ContextCompat
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import com.example.waterreporter.utils.SupabaseManager
import com.google.android.gms.location.FusedLocationProviderClient
import android.app.Application
import com.google.android.gms.location.LocationServices
import io.github.jan.supabase.gotrue.auth
import io.github.jan.supabase.postgrest.postgrest
import io.github.jan.supabase.storage.storage
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import java.util.UUID

// Data class for the report form
data class ReportFormState(
    val issueType: String = "",
    val severity: String = "Low", // Default value
    val description: String = "",
    val imageUri: Uri? = null,
    val latitude: Double? = null,
    val longitude: Double? = null,
    val isLoading: Boolean = false,
    val submissionStatus: SubmissionStatus = SubmissionStatus.Idle
)

enum class SubmissionStatus {
    Idle, Submitting, Success, Error
}

// Data class for the report to be saved in DB
@kotlinx.serialization.Serializable
data class WaterIssue(
    val user_id: String, // Should be UUID, but Supabase client might handle String conversion
    val type: String,
    val description: String,
    val severity: String,
    val image_url: String? = null,
    val latitude: Double?,
    val longitude: Double?,
    val status: String = "Pending" // Default status
    // id and timestamp are generated by DB
)

class ReportViewModel(application: Application) : AndroidViewModel(application) {

    var reportFormState by mutableStateOf(ReportFormState())
        private set

    private val _submissionResult = MutableStateFlow<String?>(null)
    val submissionResult: StateFlow<String?> = _submissionResult

    private lateinit var fusedLocationClient: FusedLocationProviderClient

    fun initLocationClient(context: Context) {
        fusedLocationClient = LocationServices.getFusedLocationProviderClient(context)
    }

    fun updateIssueType(type: String) {
        reportFormState = reportFormState.copy(issueType = type)
    }

    fun updateSeverity(level: String) {
        reportFormState = reportFormState.copy(severity = level)
    }

    fun updateDescription(text: String) {
        reportFormState = reportFormState.copy(description = text)
    }

    fun updateImageUri(uri: Uri?) {
        reportFormState = reportFormState.copy(imageUri = uri)
    }

    fun updateLocation(lat: Double, lon: Double) {
        reportFormState = reportFormState.copy(latitude = lat, longitude = lon)
    }

    fun fetchCurrentLocation(context: Context) {
        if (ContextCompat.checkSelfPermission(context, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED ||
            ContextCompat.checkSelfPermission(context, Manifest.permission.ACCESS_COARSE_LOCATION) == PackageManager.PERMISSION_GRANTED) {

            if (!::fusedLocationClient.isInitialized) {
                Log.e("ReportViewModel", "Location client not initialized. Call initLocationClient first.")
                _submissionResult.value = "Error: Location client not ready."
                reportFormState = reportFormState.copy(submissionStatus = SubmissionStatus.Error)
                return
            }

            reportFormState = reportFormState.copy(isLoading = true)
            fusedLocationClient.lastLocation
                .addOnSuccessListener { location: Location? ->
                    location?.let {
                        updateLocation(it.latitude, it.longitude)
                    } ?: run {
                         _submissionResult.value = "Could not get location. Ensure GPS is enabled."
                    }
                    reportFormState = reportFormState.copy(isLoading = false)
                }
                .addOnFailureListener { e ->
                    _submissionResult.value = "Failed to get location: ${e.message}"
                    reportFormState = reportFormState.copy(isLoading = false)
                }
        } else {
             _submissionResult.value = "Location permission not granted."
             // UI should handle requesting permission.
        }
    }

    fun submitReport() {
        viewModelScope.launch {
            reportFormState = reportFormState.copy(isLoading = true, submissionStatus = SubmissionStatus.Submitting)
            _submissionResult.value = null // Clear previous messages

            val currentUser = SupabaseManager.client.auth.currentUserOrNull()
            if (currentUser == null) {
                _submissionResult.value = "User not authenticated. Please log in."
                reportFormState = reportFormState.copy(isLoading = false, submissionStatus = SubmissionStatus.Error)
                return@launch
            }

            var imageUrl: String? = null
            if (reportFormState.imageUri != null) {
                try {
                    val imageFileName = "report_images/${currentUser.id}/${UUID.randomUUID()}"
                    // Note: The Supabase Storage client needs the file extension for content type detection.
                    // This needs to be handled by getting the extension from the URI or setting it explicitly.
                    // For simplicity, let's assume PNG for now if not derivable. This is a common point of failure.
                    // A better approach is to get extension from Uri.
                    val extension = "jpg" // Placeholder, derive from URI
                    val remotePath = "$imageFileName.$extension"

                    // The Supabase Storage client's upload function expects ByteArray.
                    // We need to convert Uri to ByteArray. This requires Context.
                    // This part is complex and better handled with a ContentResolver in the Composable or passed to VM.
                    // For now, this is a conceptual placeholder for the upload.
                    // SupabaseManager.client.storage.from("water_issues_images").upload(remotePath, byteArray)
                    // For this iteration, I will simulate the upload path generation.
                    // Actual byte upload needs context to resolve URI.

                    // The Supabase KT client as of 1.3.3 uses upload(path, uri, upsert)
                    // This requires the context to be available or passed.
                    // For now, we'll just construct the name. The actual upload will be part of UI interaction.
                    imageUrl = remotePath // This would be the URL after successful upload.

                    // Placeholder: In a real scenario, you'd upload here and get the public URL or path.
                    // For now, we'll just use the generated path as a stand-in for image_url.
                    // The actual upload will need to be triggered from the Composable that has access to context
                    // or by passing context (carefully) to ViewModel.
                    // For this example, let's assume image upload happens before this call or is handled separately.
                    // We will focus on saving the report data with a placeholder image_url if URI exists.

                    // Let's assume the image is uploaded and `imageUrl` is its path or URL from Supabase.
                    // For now, we will just use a placeholder if an image URI is present.
                    if (reportFormState.imageUri != null) {
                         // This is where the actual image upload to Supabase Storage would happen.
                         // It returns the public URL or a path that can be converted to one.
                         // This is a complex step involving URI to byte array conversion and multipart upload.
                         // For the current plan step, we'll simplify and assume it's handled.
                         // The README policy for storage: "Authenticated users can upload to their own folder"
                         // (storage.foldername(name))[1] = auth.uid()::text
                         // So the path should be like: auth.uid()/filename.ext

                        // This will be refined when implementing the UI part for image selection.
                        // For now, we'll assume `imageUrl` is correctly populated if an image is selected.
                        // The actual upload logic will be in the Composable or a helper.
                    // imageUrl = "user_uploads/${currentUser.id}/${UUID.randomUUID()}.jpg" // Example path

                    // Actual Upload:
                    val context = getApplication<Application>().applicationContext // Need context for contentResolver
                    val contentResolver = context.contentResolver
                    val inputStream = contentResolver.openInputStream(reportFormState.imageUri!!)
                    val bytes = inputStream!!.readBytes()
                    inputStream.close()

                    val extension = context.contentResolver.getType(reportFormState.imageUri!!)?.split('/')?.last() ?: "jpg"
                    val remotePath = "public/${currentUser.id}/${UUID.randomUUID()}.$extension"
                    // Ensure bucket name "water_issues_images" is correct and RLS allows user to write.
                    // The storage RLS policy was: (storage.foldername(name))[1] = auth.uid()::text
                    // So the path should be auth.uid()/filename.ext, not public/auth.uid()/...
                    // Corrected path based on typical RLS:
                    val correctedRemotePath = "${currentUser.id}/${UUID.randomUUID()}.$extension"

                    imageUrl = SupabaseManager.client.storage.from("water_issues_images").upload(correctedRemotePath, bytes, upsert = false)
                    Log.i("ReportVM", "Image uploaded, path: $imageUrl")
                    // The imageUrl returned by upload is typically just the path, not full URL.
                    // You might need to construct the full URL if needed immediately, e.g.
                    // imageUrl = SupabaseManager.client.storage.from("water_issues_images").publicUrl(correctedRemotePath)
                    // For storing in DB, often the path is enough if you reconstruct URL on retrieval.
                    }


                } catch (e: Exception) {
                    _submissionResult.value = "Image upload failed: ${e.message}"
                    reportFormState = reportFormState.copy(isLoading = false, submissionStatus = SubmissionStatus.Error)
                    Log.e("ReportVM", "Image upload error", e)
                    return@launch
                }
            }

            val report = WaterIssue(
                user_id = currentUser.id,
                type = reportFormState.issueType,
                description = reportFormState.description,
                severity = reportFormState.severity,
                image_url = imageUrl,
                latitude = reportFormState.latitude,
                longitude = reportFormState.longitude
            )

            try {
                SupabaseManager.client.postgrest.from("water_issues").insert(report)
                _submissionResult.value = "Report submitted successfully!"
                reportFormState = reportFormState.copy(isLoading = false, submissionStatus = SubmissionStatus.Success)
                resetForm() // Optionally reset form on success
            } catch (e: Exception) {
                _submissionResult.value = "Failed to submit report: ${e.message}"
                reportFormState = reportFormState.copy(isLoading = false, submissionStatus = SubmissionStatus.Error)
                Log.e("ReportVM", "DB insert error", e)
            }
        }
    }

    private fun resetForm() {
        reportFormState = ReportFormState()
    }

    // Call this when the ViewModel is no longer needed to clean up location client if necessary
    // override fun onCleared() {
    // super.onCleared()
    // May not be necessary for FusedLocationProviderClient if tied to application context
    // }
}
